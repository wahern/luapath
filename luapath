#!/bin/sh
#
# This script is used to derive compiler flags and filesystem paths
# necessary to utilize Lua, LuaJIT, and particular versions thereof in both
# simple and mixed installation environments.
#
# For usage help information use the -h switch.
#
# This script attempts to adhere strictly to POSIX shell specifications. The
# known non-POSIX features used are the path of the shell at the very first
# line of this script, and the default compiler command name of `cc' instead
# of `c99'. For any other issues please contact the author.
#
# WARNING: When searching for a Lua interpreter this script may execute
# various utilities in an attempt to deduce their fitness and release
# version. By default this script will search for and execute utilities
# using the glob patterns luac* and lua*. But this script CANNOT GUARANTEE
# that executing such utilities, or any other utilities, either wittingly or
# unwittingly, will not result in your COMPUTER EXPLODING. You have been
# warned.
#
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# 
# Notes:
#
# * Originally published 2013-08-02. Derived from an earlier script,
#   lua.path, written for the cqueues project.
#
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#
# Copyright (C) 2012-2013 William Ahern
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
set -e # strict errors
set -u # don't expand unbound variables
set -f # disable pathname expansion
set -C # noclobber
\unalias -a # no command surprises
export LC_ALL=C # no locale headaches
unset IFS # no field splitting surprises
: ${TMPDIR:=/tmp} # sane TMPDIR

MYVERSION=20130805
MYVENDOR="william@25thandClement.com"


DEVRANDOM=/dev/urandom
SANDBOX="${TMPDIR}/${0##*/}-"

INCDIRS=
LIBDIRS=
BINDIRS=
RECURSE=no
MAXDEPTH=   # full command switch, like "-maxdepth 3", if supported
XDEV=       # do not cross device boundaries; i.e. "-xdev"
SHORTEST=   # continue searching until shortest pathname found

API_MIN=500
API_MAX=999
API_VER=
API_DIR=

JIT_REQ=
JIT_MIN=20000
JIT_MAX=99999
JIT_VER=
JIT_DIR=

LUAC_PATH=
LUAC_VER=

LUA_PATH=
LUA_VER=


#
# evalmacro PATH MACRO [REGEX] [SUBST]
#
# 	PATH   Header identifier--#include <PATH>
# 	MACRO  Macro identifier
# 	REGEX  Optional regex pattern to match macro evalutation result
# 	SUBST  Optional replacement expression
#
evalmacro() {
	printf "#include <$1>\n[===[$2]===]\n" \
	| ${CC:-cc} ${CPPFLAGS:-} -E - 2>/dev/null \
	| sed -ne "
		s/^.*\\[===\\[ *\\(${3:-.*}\\) *\\]===\\].*$/${4:-\\1}/
		t Found
		d
		:Found
		p
		q
	"
}


#
# testsym PATH NAME
#
# Test whether global symbol NAME exists in object file at PATH. Exits with
# 0 (true) when found, non-0 (false) otherwise.
#
testsym() {
	# NOTE: No -P for OpenBSD nm(1), but the default output format is
	# close enough. Section types always have a leading and trailing
	# space. U section type means undefined. On AIX [VWZ] are weak
	# global symbols. Solaris and OS X have additional symbol types
	# beyond the canonical POSIX/BSD types, all of which are uppercase
	# and within [A-T].
	(nm -Pg ${1} 2>/dev/null || nm -g 2>/dev/null) \
	| sed -ne '/ [A-T] /p' \
	| grep -qE "${2}"
}


tryluainclude() {
	V="$(evalmacro ${1} LUA_VERSION_NUM '[0123456789][0123456789]*')"
	: ${V:=0}

	if [ "${1%/*}" != "${1}" ]; then
		D="${1%/*}"

		# cleanup aftering Solaris directory prune trick
		if [ "${D##*/./}" != "${D}" ]; then
			D="${D%%/./*}/${D##*/./}"
		else
			D="${D%/.}"
		fi
	else
		D=
	fi

	[ "$V" -gt 0 -a "$V" -ge "${API_VER:-0}" ] || return 0

	[ "$V" -gt "${API_VER:-0}" -o "${#D}" -lt "${#API_DIR}" -o \( "${JIT_REQ}" = "yes" -a "${JIT_VER:-0}" -lt "${JIT_MAX}" \) ] || return 0

	[ "$V" -ge "${API_MIN}" -a "$V" -le "${API_MAX}" ] || return 0

	if [ -n "${JIT_REQ}" ]; then
		J="$(evalmacro ${1%%lua.h}luajit.h LUAJIT_VERSION_NUM '[0123456789][0123456789]*')"
		: ${J:=0}

		if [ "${JIT_REQ}" = "skip" ]; then
			[ "${J}" -eq 0 ] || return 0
		elif [ "${JIT_REQ}" = "yes" ]; then
			[ "$J" -ge "${JIT_VER:-0}" ] || return 0
			[ "$J" -gt "${JIT_VER:-0}" -o "${#D}" -lt "${#JIT_DIR}" ] || return 0
			[ "$J" -ge ${JIT_MIN} ] || return 0
			[ "$J" -le "${JIT_MAX}" ] || return 0

			JIT_VER="$J"
			JIT_DIR="$D"
		fi
	fi

	API_VER="$V"
	API_DIR="$D"
}


#
# foundversion
#
# true if found the best (maximum) possible version, false otherwise
#
foundversion() {
	if [ "${API_VER:-0}" -lt "${API_MAX}" ]; then
		return 1
	fi

	if [ "${JIT_REQ}" = "yes" -a "${JIT_VER:-0}" -lt "${JIT_MAX}" ]; then
		return 1
	fi

	if [ "${SHORTEST}" = "yes" ]; then
		return 1
	fi

	return 0
}


#
# findversion
#
findversion() {
	tryluainclude "lua.h"

	if foundversion; then
		return 0
	fi

	# recurse into -I directories in CPPFLAGS
	if [ "${RECURSE}" = "yes" -a "${CPPFLAGS:-}" != "" ]; then
		set -- ${CPPFLAGS}

		while [ $# -gt 0 ]; do 
			case "${1}" in
			-I)
				shift

				if [ -n "${1:-}" ]; then
					for F in $(find ${1} ${MAXDEPTH} ${XDEV} -name lua.h -print 2>/dev/null); do
						tryluainclude "${F}"

						if foundversion; then
							return 0
						fi
					done
				fi

				;;
			-I*)
				if [ -n "${1:-}" -a "${1:-}" != "-I" ]; then
					for F in $(find ${1#-I} ${MAXDEPTH} ${XDEV} -name lua.h -print 2>/dev/null); do
						tryluainclude "${F}"

						if foundversion; then
							return 0
						fi
					done
				fi

				;;
			esac

			shift
		done
	fi

	if foundversion; then
		return 0
	fi

	[ ${#INCDIRS} -gt 0 ] || return 0

	IFS=:
	set -- ${INCDIRS}
	unset IFS

	PRUNE=

	if [ "${RECURSE}" = "no" ]; then
		PRUNE="-name . -o -type d -prune -o"
	fi

	for D; do
		for F in $(find ${D}/. ${MAXDEPTH} ${XDEV} ${PRUNE} -name lua.h -print 2>/dev/null); do
			tryluainclude "${F}"

			if foundversion; then
				return 0
			fi
		done
	done
}


findpath() {
	NAME="$1"
	WHERE="$3"

	PRUNE=

	if [ "${2}" = "no" ]; then
		PRUNE="-name . -o -type d -prune -o"
	fi

	[ ${#WHERE} -gt 0 ] || return 0

	IFS=:
	set -- ${WHERE}
	unset IFS

	for D; do
		find "${D}/." ${MAXDEPTH} ${XDEV} ${PRUNE} -name "${NAME}" -print 2>/dev/null | sed -e 's/\/\.//'
	done
}


# check setuid and setgid mode
safeperm() {
	[ -f "$1" -a ! -u "$1" -a ! -g "$1" ]
}


findluac() {
	while [ $# -gt 0 ]; do
		for F in $(findpath "${1}" no "${PATH}"; findpath "${1}" "${RECURSE}" "${BINDIRS}"); do
			[ -x "$F" ] && safeperm "$F" || continue

			V="$($F -v </dev/null 2>&1 | head -n1 | sed -ne 's/^Lua \([0123456789][0123456789]*\.[0123456789][0123456789]*\).*/\1/p')"
			: ${V:=0}
			V="$((${V%%.*} * 100 + ${V##*.} % 100))"

			[ "${V}" -gt 0 -a "${V}" -ge "${LUAC_VER:-0}" ] || continue

			[ "${V}" -gt "${LUAC_VER:-0}" -o "${#F}" -lt "${#LUAC_PATH}" ] || continue

			[ "${V}" -ge "${API_MIN}" -a "${V}" -le "${API_MAX}" ] || continue

			printf "return true" | ${F} -p - </dev/null >/dev/null 2>&1 || continue

			LUAC_PATH="$F"
			LUAC_VER="$V"

			[ "${SHORTEST}" = "yes" -o "${LUAC_VER}" -lt "${API_MAX}" ] || break 2
		done

		shift
	done
}


checkints() {
	while [ $# -gt 0 ]; do
		I="${1}"
		while [ "${#I}" -gt 0 ]; do
			if [ "${I##[0123456789]}" = "${I}" ]; then
				printf -- "${0##*/}: ${1}: not a number\n" >&2
				exit 1
			fi

			I=${I##[0123456789]}
		done

		shift
	done
}


lua2num() {
	M=0
	m="${2:-0}"

	IFS=.
	set -- ${1}
	unset IFS

	M=${1:-${M}}
	m=${2:-${m}}

	checkints $M $m

	printf "$((${M} * 100 + ${m}))\n"
}


jit2num() {
	M=0
	m="${2:-0}"
	p="${3:-0}"

	IFS=.
	set -- ${1}
	unset IFS

	M=${1:-${M}}
	m=${2:-${m}}
	p=${3:-${p}}

	checkints $M $m $p

	printf "$((${M} * 10000 + ${m} * 100 + ${p}))\n"
}


findlua() {
	while [ $# -gt 0 ]; do
		for F in $(findpath "${1}" no "${PATH}"; findpath "${1}" "${RECURSE}" "${BINDIRS}"); do
			[ -x "$F" ] && safeperm "$F" || continue

			V="$($F -e 'print(string.match(_VERSION, [[[%d.]+]]))' </dev/null 2>/dev/null | head -n1 | sed -ne 's/^\([0123456789][0123456789]*\.[0123456789][0123456789]*\).*/\1/p')"
			: ${V:=0}
			V="$((${V%%.*} * 100 + ${V##*.} % 100))"

			[ "${V}" -gt 0 -a "${V}" -ge "${LUA_VER:-0}" ] || continue

			[ "${V}" -gt "${LUA_VER:-0}" -o "${#F}" -lt "${#LUA_PATH}" ] || continue

			[ "${V}" -ge "${API_MIN}" -a "${V}" -le "${API_MAX}" ] || continue

			if [ -n "${JIT_REQ}" ]; then
				J="$($F -v </dev/null 2>&1 | head -n1 | sed -ne 's/^LuaJIT \([0123456789][0123456789]*\.[0123456789][0123456789]*\.[0123456789][0123456789]*\).*/\1/p')"
				J="$(jit2num ${J:-0})"

				if [ "${JIT_REQ}" = "skip" ]; then
					[ "${J}" -eq 0 ] || continue
				elif [ "${JIT_REQ}" = "yes" ]; then
					[ "${J}" -gt 0 ] || continue
					[ "${J}" -ge "${JIT_MIN}" ] || continue
					[ "${J}" -le "${JIT_MAX}" ] || continue
				fi
			fi

			LUA_PATH="$F"
			LUA_VER="$V"

			[ "${SHORTEST}" = "yes" -o "${LUA_VER}" -lt "${API_MAX}" ] || break 2
		done

		shift
	done
}


usage() {
	cat <<-EOF
	usage: ${0##*/} [-I:L:P:d:Drm:xsv:j:JVh] cppflags|ldflags|version|lua|luac
	  -I PATH      additional search directory for includes
	  -L PATH      additional search directory for libraries
	  -P PATH      additional search directory for binaries
	  -d PATH      use PATH as sandbox directory; a random 16 byte suffix is
	               generated from /dev/urandom and the directory removed on exit
	               unless a trailing "/" is present
	               (default sandbox is $TMPDIR/${0##*/}-XXXXXXXXXXXXXXXX)
	  -D           do not create a sandbox
	  -r           recursively search directories
	  -m MAXDEPTH  limit recursion to MAXDEPTH (only for GNU and BSD find)
	  -x           do not cross device mounts when recursing
	  -s           find shortest pathname, otherwise print first best match
	  -v VERSION   require specific Lua version or range
	               (e.g. "5.1" or "5.1-5.2")
	  -j VERSION   require specific LuaJIT version or range
	               (e.g. "2.0.1"; empty ranges like "-" force any LuaJIT version)
	  -J           skip LuaJIT if encountered
	  -V           print this script's version information
	  -h           print this usage message

	  cppflags     print derived additional CPPFLAGS necessary
	  ldflags      print derived additional LDFLAGS necessary (TODO)
	  version      print derived Lua API version
	  luac [GLOB]  print path to luac utility using optional glob patterns
	               (e.g. "luac5.?"; default is "luac*")
	  lua [GLOB]   print path to lua interpreter using optional glob patterns
	               (e.g. "lua luajit"; default is "lua*")
	  evalmacro    run internal macro evaluator for debugging
	  testsym      run internal library symbol reader for debugging

	This utility is used to derive compiler flags and filesystem paths
	necessary to utilize Lua, LuaJIT, and particular versions thereof.
	On success it prints the requested information and exits with 0,
	otherwise it fails with an exit status of 1.

	Note that cppflags may not print anything if no additional flags are
	required to compile against the requested API version.

	When searching, the highest Lua version is preferred. Searching
	stops once the highest version in the allowable range is found
	unless the -s flag is specified.

	LuaJIT is treated like any other Lua installation. If an explicit
	LuaJIT version or range is specified, then only LuaJIT installations
	will match. To exclude LuaJIT entirely use the -J switch.

	This utility processes the environment variables CC, CPPFLAGS,
	LDFLAGS, and PATH if present. If recursion is requested, then
	directories specified in CPPFLAGS, LDFLAGS, and PATH are also
	recursed.

	If no directories are specified in CPPFLAGS or with the -I switch,
	then /usr/include and /usr/local/include are used.

	Report bugs to <william@25thandClement.com>
	EOF
}


version() {
	cat <<-EOF
	luapath $MYVERSION
	vendor  $MYVENDOR
	release $MYVERSION
	EOF
}


while getopts I:L:P:d:Drm:xsv:j:JVh OPT; do
	case "${OPT}" in
	I)
		INCDIRS="${INCDIRS:-}${INCDIRS:+:}${OPTARG}"
		;;
	L)
		LIBDIRS="${LIBDIRS:-}${LIBDIRS:+:}${OPTARG}"
		;;
	P)
		BINDIRS="${BINDIRS:-}${BINDIRS:+:}${OPTARG}"
		;;
	d)
		SANDBOX="${OPTARG}"
		;;
	D)
		SANDBOX=
		;;
	r)
		RECURSE=yes
		;;
	m)
		if [ -n "${OPTARG##[0123456789]}" ]; then
			printf -- "${0##*/}: ${OPTARG}: invalid maxdepth\n" >&2
			exit 1
		fi

		if find "${TMPDIR:-/tmp}" -maxdepth ${OPTARG} -prune >/dev/null 2>&1; then
			MAXDEPTH="-maxdepth ${OPTARG}"
		else
			printf -- "${0##*/}: $(command -v find): -maxdepth unsupported\n" >&2
		fi

		;;
	x)
		XDEV="-xdev"
		;;
	s)
		SHORTEST=yes
		;;
	v)
		MIN=${OPTARG%%[,:-]*}
		MAX=${OPTARG##*[,:-]}

		API_MIN="$(lua2num ${MIN:-0} 0)"
		API_MAX="$(lua2num ${MAX:-99} 99)"

		if [ "${API_MIN}" -gt "${API_MAX}" ]; then
			printf -- "${0##*/}: ${OPTARG}: invalid version range\n" >&2
			exit 1
		fi

		;;
	j)
		MIN=${OPTARG%%[,:-]*}
		MAX=${OPTARG##*[,:-]}

		JIT_MIN="$(jit2num ${MIN:-0} 0 0)"
		JIT_MAX="$(jit2num ${MAX:-99} 99 99)"

		if [ "${JIT_MIN}" -gt "${JIT_MAX}" ]; then
			printf -- "${0##*/}: ${OPTARG}: invalid version range\n" >&2
			exit 1
		fi

		JIT_REQ=yes
		;;
	J)
		JIT_REQ=skip
		;;
	V)
		version
		exit 0
		;;
	h)
		usage
		exit 0
		;;
	*)
		usage >&2
		exit 1
		;;
	esac
done

shift $(($OPTIND - 1))


if [ -n "${SANDBOX}" ]; then
	if [ "${SANDBOX}" = "${SANDBOX%/}" ]; then
		if [ ! -c "${DEVRANDOM}" ]; then
			# FIXME: expand DEVRANDOM into set of different possibilities to check
			printf -- "${0##*/}: ${DEVRANDDOM}: no character random device available\n" >&2
			exit 1
		fi

		TMP="${SANDBOX}$(od -An -N8 -tx1 < ${DEVRANDOM} 2>/dev/null | tr -d ' ')"

		if [ ${#TMP} -ne $((${#SANDBOX} + 16)) ]; then
			printf -- "${0##*/}: ${SANDBOX}: unable to generate random suffix\n" >&2
			exit 1
		fi

		SANDBOX="${TMP}"

		trap "rm -f ${SANDBOX}/* && rmdir ${SANDBOX}" EXIT
	fi

	if [ ! -d "${SANDBOX}" ]; then
		OMASK="$(umask)"
		umask 0777
		mkdir -m0550 -- "${SANDBOX}" || exit 1
		umask ${OMASK}
	fi

	cd ${SANDBOX}
fi


case "${1:-}" in
cppflags)
	if [ -z "${CPPFLAGS:-}" -a -z "${INCDIRS}" ]; then
		INCDIRS="/usr/include:/usr/local/include"
	fi

	findversion

	[ "${API_VER:-0}" -gt 0 ] || exit 1

	[ -z "${API_DIR:-}" ] || printf -- "-I${API_DIR}\n"

	;;
ldflags)
	;;
version)
	findversion

	[ "${API_VER:-0}" -gt 0 ] || exit 1

	printf "$(((${API_VER} / 100) % 100)).$((($API_VER) % 100))\n"

	;;
luac)
	shift

	if [ $# -eq 0 ]; then
		set -- luac\*
	fi

	findluac $*

	[ -n "${LUAC_PATH}" ] || exit 1
	
	printf -- "${LUAC_PATH}\n"

	;;
lua)
	shift

	if [ $# -eq 0 ]; then
		set -- lua\*
	fi

	findlua $*

	[ -n "${LUA_PATH}" ] || exit 1
	
	printf -- "${LUA_PATH}\n"

	;;
evalmacro)
	shift

	evalmacro  $*
	;;
testsym)
	shift

	if testsym $*; then
		printf "found\n"
		exit 0
	else
		printf "not found\n"
		exit 1
	fi
	;;
*)
	if [ -n "${1:-}" ]; then
		printf -- "${0##*/}: ${1}: unknown command\n" >&2
	else
		printf -- "${0##*/}: no command specified\n" >&2
	fi

	exit 1
	;;
esac

exit 0
