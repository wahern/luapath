#!/bin/sh
#
# Copyright (C) 2015 William Ahern
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
# ----------------------------------------------------------------------------
# DESCRIPTION
#
# runlua is a POSIX shell script for locating and executing specific Lua
# interpreter versions. For example, the environment's Lua 5.1 interpreter
# might be named lua, lua5.1, lua51, luajit, luajit2.0.2, etc.
# ----------------------------------------------------------------------------
# PORTING NOTES
#
# unset) On NetBSD (confirmed up to 6.1.5) unset NAME will exit with a
#   failure status if no such variable is set. If errexit (set -e) is
#   enabled then the shell will exit. See NetBSD PR 49595.
#
# #!) Linux and OS X permit recursive shebang execution, which some users
#   might wish to take advantage of. However, neither will field-split
#   interpreter arguments, instead passing the remainder of the shebang line
#   as a single positional argument. So we manually field-split any first
#   argument.
#
#   Solaris (confirmed 11.1), AIX (confirmed 7.1), OpenBSD (confirmed 5.5),
#   NetBSD (confirmed 5.1.2, 6.1.1), and FreeBSD (confirmed 9.0) will search
#   for the interpreter recursively, following shebang interpreter paths
#   until a binary interpreter is found. But they will not add each
#   intervening interpreter path to the positional argument list. If you
#   don't know the paths you cannot execute them recursively.
#
# $@) On some BSD shells (confirmed NetBSD 5.1.2, 6.1.1, OpenBSD 5.5)
#   expansion of an empty $@ will wrongly trigger an error if nounset (set
#   -u) is in effect.
#
# noclobber) On some BSD shells (confirmed NetBSD 5.1.2, 6.1.1) the
#   noclobber (set -C) option will wrongly cause redirection to /dev/null
#   using the redirect operator (">") to fail. Use the appending redirect
#   operator (">>") as a workaround.
#
# trap EXIT) On AIX (confirmed 7.1) ksh wrongly executes an EXIT trap when
#   the calling function returns, rather than when the shell exits. Note
#   ksh93 does not exhibit this bug.
#
set -e # strict error
set -u # don't expand unbound variable
set -f # disable pathname expansion
set -C # noclobber

unset IFS
"unalias" -a

_LC_ALL="${LC_ALL+X}${LC_ALL-}"
export LC_ALL=C

: ${PATH:=$(command -p getconf PATH)}
: ${TMPDIR:=/tmp}

MYVERSION=20150122
MYVENDOR="william@25thandClement.com"

LUA_MIN=10000
LUA_MAX=999999
JIT_MIN=00000
JIT_MAX=999999

TMPWD=
DEBUG=

warn() {
	if [ -n "${DEBUG:-}" -a -t 2 ]; then
		printf "\033[0;31m%s: %.0s${1}\033[0m\n" "${0##*/}" "$@" >&2
	else
		printf "%s: %.0s${1}\n" "${0##*/}" "$@" >&2
	fi
}

panic() {
	warn "$@"
	exit 1
}

debug() {
	if [ -n "${DEBUG:-}" ]; then
		printf "%s: %.0s${1}\n" "${0##*/}" "$@" >&2
	fi
}

tempnam() {
	printf "%s-%s\n" "${1}" "$(od -An -N8 -tx1 -v /dev/urandom 2>>/dev/null | tr -cd '0-9a-f')"
}

# isinteger STRING
isinteger() {
	I="${1}"

	[ "${#I}" -gt 0 ] || return 1

	while [ "${#I}" -gt 0 ]; do
		[ "${I##[0123456789]}" != "${I}" ] || return 1
		I="${I##[0123456789]}"
	done
}

# ver2num STRING [MAJOR] [MINOR] [PATCH]
ver2num() {
	M="${2:-0}"
	m="${3:-0}"
	p="${4:-0}"

	IFS="."
	set -- ${1}
	unset IFS

	if isinteger "${1:-}"; then
		M=${1}
	fi

	if isinteger "${2:-}"; then
		m=${2}
	fi

	if isinteger "${3:-}"; then
		p=${3}
	fi

	printf "$((${M} * 10000 + ${m} * 100 + ${p}))\n"
}

num2ver() {
	M=$((${1} / 10000 % 100))
	m=$((${1} / 100 % 100))
	p=$((${1} % 100))
	printf "${M}.${m}.${p}\n"
}

num2api() {
	printf "$((${1} / 10000 % 100)).$((${1} / 100 % 100))\n"
}

getapi() {
	if [ -x "${1}" ]; then
		ver2num "$(noenv; cdwd; "${1}" -e 'print(string.match(_VERSION, [[[%d.]+]]))' </dev/null 2>>/dev/null || true)"
	fi
}

getrel() {
	if [ -x "${1}" ]; then
		ver2num "$(noenv; cdwd; "${1}" -v </dev/null 2>&1 | sed -ne 's/^Lua[^ ]* \([0-9][0-9\.]*\).*/\1/p' | head -n1)"
	fi
}

cdwd() {
	if [ -n "${TMPWD:-}" ]; then
		cd "${TMPWD}"
	fi
}

mkwd() {
	TMPWD="$(tempnam "${TMPDIR}/${0##*/}")"
	debug "creating working directory %s" "${TMPWD}"
	mkdir -m0500 "${TMPWD}"
}

trap "rmwd" EXIT # see portability note "trap EXIT"

rmwd() {
	if [ -n "${TMPWD:-}" -a -d "${TMPWD}" ]; then
		debug "removing working directory %s" "${TMPWD}"
		rmdir -- "${TMPWD}"
		TMPWD=
	fi
}

findlua() {
	if [ -n "${LUA:-}" ]; then
		printf "%s\n" "${LUA}"
		return 0
	fi

	mkwd

	found_PATH=
	found_API=0
	found_REL=0

	# leverage shell pathname expansion to locate interpreter by
	# iterating over $PATH directories and letting shell do the search
	IFS=:
	set -- ${PATH}
	unset IFS

	for D; do
		# get abspath because getapi and getrel cd to working directory
		D="$(! cd "${D}" 2>>/dev/null || pwd)"
		[ -n "${D}" ] || continue

		set -- "false" # see porting note "$@"
		set +f
		if [ ! $JIT_MIN -gt 0 ]; then # PUC Lua
			set -- "$@" ${D}/lu[a] ${D}/lua5*
		fi
		if [ $JIT_MAX -gt 0 ]; then # LuaJIT
			set -- "$@" ${D}/luajit*
		fi
		set -f

		for F; do
			# skip empty or dummy paths
			[ ${#F} -gt 0 -a "${F}" != "false" ] || continue

			# skip paths with wildcards
			[ "${F#*[*]}" = "${F}" ] || continue
			[ "${F#*[[]}" = "${F}" ] || continue

			V="$(getapi "${F}")"
			R="$(getrel "${F}")"
			: ${V:=0}
			: ${R:=0}

			debug "%s is version %s (%s API)" "${F}" "$(num2ver "${R}")" "$(num2api "${V}")"

			if [ ${V} -ge ${LUA_MIN} -a ${V} -le ${LUA_MAX} ]; then
				if [ ${V} -gt 0 -a ${V} -ge ${found_API} -a ${R} -gt ${found_REL} ]; then
					found_PATH="${F}"
					found_API=${V}
					found_REL=${R}
				fi
			fi
		done
	done

	rmwd

	LUA="${found_PATH}"

	[ -n "${LUA}" ] || panic "unable to locate Lua interpreter"

	debug "using %s" "${LUA}"

	printf "%s\n" "${LUA}"
}

escape() {
	printf "%s" "${1}" | \
	od -An -tu1 -v | \
	sed -e 's/\([0123456789][0123456789]*\)/\\\1/g' | \
	tr -cd '\\0123456789'
}

quote() {
	I=$#
	while [ $I -gt 0 ]; do
		set -- "$@" "\"$(escape "${1}")\""
		shift 1
		I=$(($I - 1))
	done

	IFS=","
	printf "%s" "$*"
	unset IFS
}

noenv() {
	for F in $(env | sed -ne 's/^\(LUA_C\{0,1\}PATH[_0123456789]*\).*$/\1/p' -e 's/^\(LUA_INIT[_0123456789]*\).*$/\1/p'); do
		unset "$F" || true # see porting note "unset"
	done
}

loader() {
	S=$1 # number of lines to skip
	shift 1

	cat <<-EOF
	local function loadpath(skip, path)
		local fh = assert(io.open(path, "r"))
		local buf = {}

		for ln in fh:lines() do
			if skip > 0 then
				skip = skip - 1
			else
				buf[#buf + 1] = ln
			end
		end

		fh:close()

		return (loadstring or load)(table.concat(buf, "\n"), "@"..path)
	end

	return (function (skip, path, ...)
		if path == "-" then
			path = "/dev/stdin"
		end

		return (loadpath(skip, path))(...)
	end)(${S}, $(quote "$@"))
	EOF
}

usage() {
	cat <<-EOF
	Usage: ${0##*/} [-e:l:vEr:j:Js:tdpVh] PATH [...]
	  -e STRING  execute statement
	  -l STRING  require package
	  -v         print interpreter version information
	  -E         ignore environment variables
	  -r RANGE   run specific Lua version
	  -j RANGE   run specific LuaJIT version
	  -J         exclude LuaJIT from candidate interpreters
	  -s NUMBER  number of lines to skip when loading script
	  -t         preload POSIX threading library
	  -d         enable debug logging
	  -p         print path of Lua interpreter
	  -V         print runlua version information
	  -h         print this usage message

	BNF:
	  <PATH>    ::= <STRING>
	  <RANGE>   ::= <VERSION> | [VERSION] "-" [VERSION]
	  <VERSION> ::= <NUMBER> ["." <NUMBER> ["." <NUMBER>]]

	Examples:
	  -j2.1      only run LuaJIT 2.1 interpreter
	  -r5.2.1    only run PUC Lua 5.2.1 interpreter
	  -r5.1      run any Lua 5.1 interpreter, including LuaJIT
	  -r5.2-5.3  run any Lua 5.2 or 5.3 interpreter
	  -r5.2-     run any Lua 5.2 or later interpreter

	Report bugs to <william@25thandClement.com>
	EOF
}

version() {
	cat <<-EOF
	runlua  $MYVERSION
	vendor  $MYVENDOR
	release $MYVERSION
	EOF
}

#
# Field-split first argument. See porting note "#!".
#
# If we only have one argument than it's either a script path or we're not
# running as a shebang interpreter. If we have zero than We don't want to
# accidentally field-split the script path becaues it might contain spaces.
#
if [ $# -ge 2 ]; then
	TMP="${1}"
	shift 1
	IFS=" "
	set -- ${TMP} "$@"
	unset IFS
fi

ARGC=0
pusharg() {
	eval "ARG${ARGC}=\"\${1}\""
	ARGC=$((${ARGC} + 1))
}

SKIP=
PRINT=

while getopts "e:l:vEr:j:Js:tdpVh" OPTC; do
	case "${OPTC}" in
	e)
		pusharg "-e"
		pusharg "${OPTARG}"
		;;
	l)
		pusharg "-l"
		pusharg "${OPTARG}"
		;;
	v)
		pusharg "-v"
		;;
	E)
		noenv
		;;
	r)
		LUA_MIN="$(ver2num "${OPTARG%%[,:-]*}" 1 0 0)"
		LUA_MAX="$(ver2num "${OPTARG##*[,:-]}" 99 99 99)"
		;;
	j)
		JIT_MIN="$(ver2num "${OPTARG%%[,:-]*}" 1 0 0)"
		JIT_MAX="$(ver2num "${OPTARG##*[,:-]}" 99 99 99)"
		;;
	J)
		JIT_MIN=0
		JIT_MAX=0
		;;
	s)
		isinteger "${OPTARG}" || panic "%s: not an integer" "${OPTARG}"
		SKIP="${OPTARG}"
		;;
	t)
		export LD_PRELOAD="libpthread.so"
		;;
	d)
		DEBUG=yes
		;;
	p)
		PRINT=yes
		;;
	V)
		version
		exit 0
		;;
	h)
		usage
		exit 0
		;;
	*)
		usage >&2
		exit 1
		;;
	esac
done

shift $((${OPTIND} - 1))

#
# If we have to skip any lines we need to load and execute the script
# through the -e option.
#
if [ $# -gt 0 -a -n "${SKIP:-}" ]; then
	set -- "-e" "$(loader "${SKIP}" "$@")"
fi

#
# Prepend our argument stack to the positional list.
#
if [ ${ARGC} -gt 0 ]; then
	# first append to our positional list
	I=0
	while [ ${I} -lt ${ARGC} ]; do
		eval "ARG=\"\${ARG${I}}\""

		if [ $# -gt 0 ]; then
			set -- "$@" "${ARG}"
		else
			set -- "${ARG}"
		fi

		I=$(($I + 1))
	done

	# then rotate left
	I=0
	N=$(($# - ${ARGC}))
	while [ ${I} -lt ${N} ]; do
		set -- "$@" "${1}"
		shift 1

		I=$(($I + 1))
	done
fi

findlua >>/dev/null

if [ "${PRINT:-}" = "yes" ]; then
	printf "%s\n" "${LUA}"
	exit 0
fi

if [ -n "${_LC_ALL}" ]; then
	LC_ALL="${_LC_ALL#X}"
else
	unset LC_ALL
fi

# see portability note "$@"
if [ $# -gt 0 ]; then
	exec "${LUA}" "$@"
else
	exec "${LUA}"
fi
